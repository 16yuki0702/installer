package cluster

import (
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"

	"github.com/openshift/installer/data"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/kubeconfig"
	"github.com/openshift/installer/pkg/terraform"
)

const (
	stateFileName = "terraform.state"
)

// Cluster uses the terraform executable to launch a cluster
// with the given terraform tfvar and generated templates.
type Cluster struct {
	file *asset.File
}

var _ asset.WritableAsset = (*Cluster)(nil)

// Name returns the human-friendly name of the asset.
func (c *Cluster) Name() string {
	return "Cluster"
}

// Dependencies returns the direct dependency for launching
// the cluster.
func (c *Cluster) Dependencies() []asset.Asset {
	return []asset.Asset{
		&TerraformVariables{},
		&kubeconfig.Admin{},
	}
}

// Generate launches the cluster and generates the terraform state file on disk.
func (c *Cluster) Generate(parents asset.Parents) error {
	terraformVariables := &TerraformVariables{}
	adminKubeconfig := &kubeconfig.Admin{}
	parents.Get(terraformVariables, adminKubeconfig)

	// Copy the terraform.tfvars to a temp directory where the terraform will be invoked within.
	tmpDir, err := ioutil.TempDir(os.TempDir(), "openshift-install-")
	if err != nil {
		return errors.Wrap(err, "failed to create temp dir for terraform execution")
	}
	defer os.RemoveAll(tmpDir)

	terraformVariablesFile := terraformVariables.Files()[0]
	if err := ioutil.WriteFile(filepath.Join(tmpDir, terraformVariablesFile.Filename), terraformVariablesFile.Data, 0600); err != nil {
		return errors.Wrap(err, "failed to write terraform.tfvars file")
	}

	platform := terraformVariables.platform
	if err := data.Unpack(tmpDir, platform); err != nil {
		return err
	}

	if err := data.Unpack(filepath.Join(tmpDir, "config.tf"), "config.tf"); err != nil {
		return err
	}

	logrus.Infof("Using Terraform to create cluster...")

	// This runs the terraform in a temp directory, the tfstate file will be returned
	// to the asset store to persist it on the disk.
	if err := terraform.Init(tmpDir); err != nil {
		return errors.Wrap(err, "failed to initialize terraform")
	}

	stateFile, err := terraform.Apply(tmpDir)
	if err != nil {
		err = errors.Wrap(err, "failed to run terraform")
	}

	data, err2 := ioutil.ReadFile(stateFile)
	if err2 != nil {
		if err == nil {
			err = err2
		} else {
			logrus.Errorf("Failed to read tfstate: %v", err2)
		}
	}

	c.file = &asset.File{
		Filename: stateFileName,
		Data:     data,
	}

	// TODO(yifan): Use the kubeconfig to verify the cluster is up.
	return nil
}

// Files returns the files generated by the asset.
func (c *Cluster) Files() []*asset.File {
	return []*asset.File{c.file}
}
