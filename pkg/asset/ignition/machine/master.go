package machine

import (
	"encoding/json"
	"fmt"

	igntypes "github.com/coreos/ignition/config/v2_2/types"
	"github.com/pkg/errors"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/asset/tls"
)

// Master is an asset that generates the ignition config for master nodes.
type Master struct {
	Configs  []*igntypes.Config
	FileList []*asset.File
}

var _ asset.WritableAsset = (*Master)(nil)

// Dependencies returns the assets on which the Master asset depends.
func (a *Master) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
		&tls.RootCA{},
	}
}

// Generate generates the ignition config for the Master asset.
func (a *Master) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	rootCA := &tls.RootCA{}
	dependencies.Get(installConfig, rootCA)

	a.Configs = make([]*igntypes.Config, installConfig.Config.MasterCount())
	for i := range a.Configs {
		a.Configs[i] = pointerIgnitionConfig(installConfig.Config, rootCA.Cert(), "master", fmt.Sprintf("etcd_index=%d", i))
	}

	a.FileList = make([]*asset.File, len(a.Configs))
	for i, c := range a.Configs {
		data, err := json.Marshal(c)
		if err != nil {
			return errors.Wrap(err, "failed to marshal ignition config")
		}
		a.FileList[i] = &asset.File{
			Filename: fmt.Sprintf("master-%d.ign", i),
			Data:     data,
		}
	}

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *Master) Name() string {
	return "Master Ignition Config(s)"
}

// Files returns the files generated by the asset.
func (a *Master) Files() []*asset.File {
	return a.FileList
}

// Load returns the master ignitions from disk.
func (a *Master) Load(f asset.FileFetcher) (found bool, err error) {
	fileList, err := f.FetchByPattern("master-[0-9]*.ign")
	if err != nil {
		return false, nil
	}
	if len(fileList) == 0 {
		return false, nil
	}

	configs := make([]*igntypes.Config, len(fileList))
	for i, file := range fileList {
		configs[i] = &igntypes.Config{}
		if err := json.Unmarshal(file.Data, configs[i]); err != nil {
			return false, errors.Wrapf(err, "failed to unmarshal")
		}
	}

	a.FileList, a.Configs = fileList, configs

	return true, nil
}
